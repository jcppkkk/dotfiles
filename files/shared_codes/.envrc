#!/bin/bash
#
# Install https://direnv.net/ to load this file automatically
#

if [[ -n "${ENVRC:-}" ]]; then
    return
fi
export ENVRC=1

# Hook pre-commit
if [[ -f .pre-commit-config.yaml ]] \
    && command -v pre-commit &>/dev/null \
    && ! grep -q pre-commit .git/hooks/pre-commit; then
    echo "direnv: initializing pre-commit"
    pre-commit install
fi

if [[ -d .envrc.d ]]; then
    # Load all .envrc files in .envrc.d directory, guard against sourcing errors.
    for file in .envrc.d/*.sh; do
        source_env_if_exists "$file"
    done
fi

# Config git .env sanitize
if [[ -f .env ]]; then
    chmod -c 0600 .env
    # Load .env file
    dotenv .env

    # Configure git filter to store and restore env values
    # Create .git/ directory if it doesn't exist
    mkdir -p .git

    # shellcheck disable=SC2016

    # Function to generate clean filter script content
    generate_clean_filter() {
        cat <<'EOF'
#!/bin/bash
# 使用 awk 來簡化配置合併邏輯
# 直接合併 .env 和 .env-store 檔案，跳過系統變數

# 過濾並合併配置檔案
{
    # 如果 .env-store 存在，先輸出（優先級較低）
    if [[ -f .env-store ]]; then
        cat .env-store
    fi
    # 輸出 .env 檔案（優先級較高，會覆蓋重複的 key）
    if [[ -f .env ]]; then
        cat .env
    fi
} | awk '
    # 處理包含 = 的值，只分割第一個 = 符號
    /^[^=]+=/ {
        # 找到第一個 = 的位置
        pos = index($0, "=")
        if (pos > 0) {
            key = substr($0, 1, pos-1)

            # 使用 awk 邏輯：後面的值會覆蓋前面的值
            if (!seen[key]++) {
                print
            } else {
                val[key] = $0
            }
        }
    }
    END {
        for(k in val) print val[k]
    }
' | sort > .env-store

# 處理輸入並輸出到 filter stdout
sed -E -e "/^[^#=]+=/s/=.*/=/" -

chmod 0600 .env-store
EOF
    }

    # Function to generate smudge filter script content
    generate_smudge_filter() {
        cat <<'EOF'
#!/bin/bash
# shellcheck disable=SC2016
if [[ -f .env-store ]]; then
    set -a
    # shellcheck source=/dev/null
    source .env-store
    set +a
fi
while IFS= read -r line; do
    if echo "$line" | grep -qE '^[^#=]+='; then
        key=$(echo "$line" | cut -d= -f1)
        value="${!key}"
        # 如果值包含空格或特殊字符，需要用雙引號包圍
        if [[ "$value" =~ [[:space:]] ]] || [[ "$value" =~ [\"\$\`\\] ]]; then
            echo "$key=\"$value\""
        else
            echo "$key=$value"
        fi
    else
        echo "$line"
    fi
done
EOF
    }

    # Function to setup a specific git filter hook
    setup_hook() {
        local hook_type="$1"
        local script_file=".git/${hook_type}_filter.sh"
        local git_config_key="filter.sanitize-env.${hook_type}"
        local generate_function="generate_${hook_type}_filter"
        local need_update=false
        local reason=""

        # Check if script exists
        if [[ ! -f "$script_file" ]]; then
            need_update=true
            reason="script file missing"
        else
            # Generate expected hash and compare with actual
            local expected_hash
            local actual_hash

            expected_hash=$($generate_function | sha256sum | cut -d' ' -f1)
            actual_hash=$(sha256sum "$script_file" 2>/dev/null | cut -d' ' -f1)

            if [[ "$actual_hash" != "$expected_hash" ]]; then
                need_update=true
                reason="script content mismatch"
                echo "direnv: ${hook_type} script hash mismatch: expected=$expected_hash, actual=$actual_hash"
            fi
        fi

        # Check git config
        local expected_config_value=".git/${hook_type}_filter.sh"
        if [[ $(git config --get "$git_config_key") != "$expected_config_value" ]]; then
            echo "direnv: configuring git filter for .env"
            git config "$git_config_key" "$expected_config_value"
            need_update=true
            reason="git config updated"
        fi

        # Regenerate script if needed
        if [[ "$need_update" == "true" ]]; then
            echo "direnv: regenerating ${hook_type} filter script ($reason)"
            $generate_function >"$script_file"
            chmod +x "$script_file"
        fi
    }

    # Setup both git filter hooks
    setup_hook clean
    setup_hook smudge

    if ! grep "^/.env" .gitattributes &>/dev/null; then
        echo "/.env filter=sanitize-env" >>.gitattributes
    fi

    # Remove unused .env files from .gitignore
    sed -E -i '/^\/\.env$|^\/\.env-store$/d' .gitignore

    # Add .env-store to .gitignore if not already present
    if ! grep "^/.env-store\*$" .gitignore &>/dev/null; then
        echo "/.env-store*" >>.gitignore
    fi
fi

# Load python environment
if [[ -f uv.lock ]]; then
    if [[ ! -d .venv ]]; then
        echo "direnv: creating uv venv"
        uv sync --venv .venv
    fi
    export VIRTUAL_ENV=."venv"
    layout python
elif [[ -f pyproject.toml ]] && command -v poetry &>/dev/null && grep -q poetry pyproject.toml; then
    log_status "loading Poetry"

    if ! direnv_load poetry run direnv dump; then
        log_error "failed to enter Poetry env, do you need 'poetry install'?"
        return 2
    fi
elif [[ -f Pipfile ]]; then
    echo "direnv: loading Pipenv"
    layout pipenv
fi
