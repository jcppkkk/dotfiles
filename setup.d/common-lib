#!/bin/bash
# shellcheck shell=bash
# vim: set et fenc=utf-8 ff=unix sts=4 sw=4 ts=8 :

function clean_up() {
    :
}

function errexit() {
    local err=$?
    set +o xtrace
    local code="${1:-1}"
    echo "Error in ${BASH_SOURCE[1]}:${BASH_LINENO[0]}. '${BASH_COMMAND}' exited with status $err"
    # Print out the stack trace described by $function_stack
    if [ ${#FUNCNAME[@]} -gt 2 ]; then
        echo "Call tree:"
        for ((i = 1; i < ${#FUNCNAME[@]} - 1; i++)); do
            echo " $i: ${BASH_SOURCE[$i + 1]}:${BASH_LINENO[$i]} ${FUNCNAME[$i]}(...)"
        done
    fi
    echo "Exiting with status ${code}"
    clean_up
    exit "${code}"
}

# 定義顏色
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

pass() {
    echo -e "${GREEN}[PASS]${NC} $1"
}

change() {
    echo -e "${YELLOW}[CHANGE]${NC} $1"
}

fail() {
    echo -e "${RED}[FAIL]${NC} $1"
}

source /etc/lsb-release
if [[ $DISTRIB_ID = LinuxMint ]] && [[ -f /etc/upstream-release/lsb-release ]]; then
    # for Linux Mint, we treat it as Ubuntu
    source /etc/upstream-release/lsb-release
fi

case $(uname) in
    Linux)
        platform='linux'
        ;;
    FreeBSD)
        platform='freebsd'
        ;;
    Darwin)
        platform='mac'
        ;;
    *)
        # shellcheck disable=SC2034
        platform='unknown'
        ;;
esac

ubuntu_apt_update() {
    local SOURCES_LIST="/etc/apt/sources.list"
    local XATTR_META="user.apt_meta"
    local UPDATE_INTERVAL=86400 # 1 day in seconds
    local changes=()

    # 檢查必要檔案和權限
    if [ ! -f "$SOURCES_LIST" ]; then
        echo "Error: $SOURCES_LIST not found" >&2
        return 1
    fi
    if [ ! -d "/etc/apt/sources.list.d" ]; then
        echo "Error: /etc/apt/sources.list.d not found" >&2
        return 1
    fi

    # 取得或更新 metadata (format: timestamp;content:hash;file1:hash;file2:hash)
    get_meta() {
        getfattr -n "$XATTR_META" "$SOURCES_LIST" 2>/dev/null | grep -o '".*"' | tr -d '"' || echo ""
    }
    save_meta() {
        if ! sudo setfattr -n "$XATTR_META" -v "$1" "$SOURCES_LIST"; then
            echo "Error: Failed to save metadata" >&2
            return 1
        fi
    }
    get_hash() {
        if [ ! -f "$1" ]; then
            echo "Error: File not found - $1" >&2
            return 1
        fi
        sha256sum "$1" 2>/dev/null | cut -d' ' -f1 || echo ""
    }

    # 建立當前狀態的 metadata
    local curr_meta old_meta old_time need_update file
    curr_meta="$(date +%s)"

    # 收集所有當前的 list 檔案路徑
    declare -A current_files
    mapfile -d $'\0' -t files < <(find /etc/apt -name "*.list" -print0)
    for file in "${files[@]}"; do
        [[ ! -f "$file" ]] && continue
        local file_hash
        file_hash=$(get_hash "$file") || continue
        current_files["$file"]="$file_hash"
        curr_meta+=";$file:$file_hash"
    done

    # 分析變更
    old_meta=$(get_meta)
    old_time=$(echo "$old_meta" | cut -d';' -f1)
    need_update=0

    # 時間檢查
    if [ -z "$old_time" ] || [ $(($(date +%s) - old_time)) -gt $UPDATE_INTERVAL ]; then
        changes+=("更新間隔超過 1 天")
        need_update=1
    fi

    # 檔案變更檢查
    if [ -n "$old_meta" ]; then
        # 建立舊檔案的 hash map
        mapfile -d ";" -t old_meta <<<"$old_meta;"
        declare -A old_files
        for entry in "${old_meta[@]}"; do
            [[ -z "$entry" ]] && continue
            [[ ! "$entry" = *:* ]] && continue
            local old_file=${entry%:*}
            local old_hash=${entry#*:}
            old_files["$old_file"]="$old_hash"
        done

        # 比對檔案變更
        for file in "${!current_files[@]}"; do
            if [ -n "${old_files[$file]}" ]; then
                # 檔案存在，檢查 hash 是否變更
                if [ "${current_files[$file]}" != "${old_files[$file]}" ]; then
                    changes+=("變更: $file [${old_files[$file]}] -> [${current_files[$file]}]")
                    need_update=1
                fi
                unset "old_files[$file]"
            else
                # 新檔案
                changes+=("新增: $file")
                need_update=1
            fi
        done

        # 剩下在 old_files 中的就是被刪除的檔案
        for file in "${!old_files[@]}"; do
            changes+=("刪除: $file")
            need_update=1
        done
    else
        changes+=("初始化")
        need_update=1
    fi

    # 執行更新
    if [ $need_update -eq 1 ]; then
        echo "變更摘要："
        printf '%s\n' "${changes[@]}"

        # 更換鏡像站
        #for list_file in "${!current_files[@]}"; do
        #    sudo sed -i 's/archive.ubuntu.com\|security.ubuntu.com/free.nchc.org.tw/' "$list_file"
        #done

        # 確保 apt update 成功執行
        if ! sudo apt update; then
            echo "Error: apt update failed" >&2
            return 1
        fi

        # 儲存新的 metadata
        save_meta "$curr_meta" || return 1
    else
        pass "apt repositories are up to date"
    fi
}

# trap ERR to provide an error handler whenever a command exits nonzero
#  this is a more verbose version of set -o errexit
trap 'errexit' ERR
# setting errtrace allows our ERR trap handler to be propagated to functions,
#  expansions and subshells
set -o errtrace
set -eE
